//
//  MinimapView.swift
//  
//
//  Created by Manuel M T Chakravarty on 05/05/2021.
//
//  TextKit 2 subclasses to implement minimap functionality.
//
//  The idea here is that, in place of drawing the actual glyphs, we draw small rectangles in the glyph's foreground
//  colour. Instead of actual glyphs, we draw fixed-sized rectangles. The size of the minimap rectangles corresponds
//  to that of the main code view font, but at a fraction of the fontsize determined by `minimapRatio`.
//
//  The implementation generates custom `NSTextParagraph`s with a font scaled down by a factor of `minimapRatio`. We
//  achieve this with a custom `NSTextContentStorageDelegate`. This implies that we cannot use the some
//  `NSTextContentStorage` for a code view and for its associated minimap. This is somewhat of a problem, because
//  TextKit 2 only supports a single `NSTextContentStorage` for a given `NSTextStorage`. To work around this
//  limitation, we define two custom subclasses of `NSTextStorage`, namely `CodeContentStorage` and 
//  `TextStorageObserver`, where the former serves as the principal code storage and the latter functions as a read-only
//  forwarder for the minimap.
//
//  To replace the standard glyph drawing by drawing of the rectangle, we subclass `NSTextLineFragment` and use a
//  subclass of `NSTextLayoutFragment` to generate the custom `NSTextLineFragment`.

import SwiftUI


/// The factor determining how much smaller the minimap is than the actual code view.
///
let minimapRatio = CGFloat(8)


#if os(macOS)

// MARK: -
// MARK: Minimap view for macOS

/// Customised text view for the minimap.
///
class MinimapView: NSTextView {
  weak var codeView: CodeView?

  // Highlight the current line.
  //
  override func drawBackground(in rect: NSRect) {
    let rectWithinBounds = rect.intersection(bounds)
    super.drawBackground(in: rectWithinBounds)

    guard let textLayoutManager  = textLayoutManager,
          let textContentStorage = textContentStorage
    else { return }

    let viewportRange = textLayoutManager.textViewportLayoutController.viewportRange

    // If the selection is an insertion point, highlight the corresponding line
    if let location     = insertionPoint,
       let textLocation = textContentStorage.textLocation(for: location)
    {
      if viewportRange == nil
          || viewportRange!.contains(textLocation)
          || viewportRange!.endLocation.compare(textLocation) == .orderedSame
      {
        drawBackgroundHighlight(within: rectWithinBounds,
                                forLineContaining: textLocation,
                                withColour: codeView?.theme.currentLineColour ?? .textBackgroundColor)
      }
    }
  }
}

#endif


// MARK: -
// MARK: Minimap attribute injection

class MinimapContentStorageDelegate: NSObject, NSTextContentStorageDelegate {

  func textContentStorage(_ textContentStorage: NSTextContentStorage, textParagraphWith range: NSRange)
  -> NSTextParagraph?
  {
    let text = NSMutableAttributedString(attributedString: 
                                         textContentStorage.attributedString!.attributedSubstring(from: range)),
        font = if range.length > 0,
                  let font = text.attribute(.font, at: 0, effectiveRange: nil) as? NSFont { font }
               else { NSFont.monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular) }
    text.addAttribute(.font, 
                      value: NSFont.userFixedPitchFont(ofSize: font.pointSize / minimapRatio)!,
                      range: NSRange(location: 0, length: range.length))

    return NSTextParagraph(attributedString: text)
  }
}


// MARK: -
// MARK: Minimap layout functionality 

class MinimapLineFragment: NSTextLineFragment {

  /// Text line fragment that we base our derived fragment on.
  ///
  /// `NSTextLineFragment` is a class cluster; hence, we need to embded a fragment generated by TextKit for us to get
  /// at its properties.
  ///
  private var textLineFragment: NSTextLineFragment

  /// The advacement per glyph (for a monospaced font).
  ///
  private let advancement: CGFloat

  init(_ textLineFragment: NSTextLineFragment) {
    self.textLineFragment = textLineFragment

    let attributedString = textLineFragment.attributedString,
        range            = textLineFragment.characterRange

    // Determine the advancement per glyph (assuming a monospaced font)
    let font = if range.length > 0,
                  let font = attributedString.attribute(.font, at: range.location, effectiveRange: nil) as? NSFont { font }
               else { NSFont.monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular) }
    advancement = font.maximumAdvancement.width

    super.init(attributedString: attributedString, range: range)
  }

  required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") }

  override var glyphOrigin: CGPoint { textLineFragment.glyphOrigin }

  override var typographicBounds: CGRect { textLineFragment.typographicBounds }

  override func characterIndex(for point: CGPoint) -> Int { textLineFragment.characterIndex(for: point) }

  override func fractionOfDistanceThroughGlyph(for point: CGPoint) -> CGFloat {
    textLineFragment.fractionOfDistanceThroughGlyph(for: point)
  }

  override func locationForCharacter(at index: Int) -> CGPoint {
    textLineFragment.locationForCharacter(at: index)
  }

  // We don't draw white space and control characters
  private let hiddenCharacterers = CharacterSet.whitespacesAndNewlines.union(CharacterSet.controlCharacters)

  // Draw boxes using a character's foreground colour instead of actual glyphs.
  override func draw(at point: CGPoint, in context: CGContext) {
    let numberOfGlyphs = Int(typographicBounds.width / advancement),
        string         = attributedString.attributedSubstring(from: characterRange).string

    // Leave some space between glyph boxes on adjacent lines
    let gap       = typographicBounds.height * 0.3
    var glyphRect = CGRect(x: point.x,
                           y: floor(point.y + gap / 2),
                           width: ceil(advancement),
                           height: typographicBounds.height - gap)

    // NB: We assume that each character in `string` corresponds to one glyph.
    for (i, character) in string.enumerated() {
      if i >= numberOfGlyphs { break }    // just in case...

      if let uni = character.unicodeScalars.first,
         !hiddenCharacterers.contains(uni)
      {

        let index = string.distance(from: string.startIndex, to: string.index(string.startIndex, offsetBy: i))
        // TODO: could try to optimise by using the `effectiveRange` of the attribute lookup to compute an entire glyph run to draw as one rectangle
        if let colour = attributedString.attribute(.foregroundColor, at: index, effectiveRange: nil) as? NSColor {
          colour.withAlphaComponent(0.50).setFill()
        }
        NSBezierPath(rect: CGRect(origin: CGPoint(x: floor(glyphRect.minX), y: glyphRect.minY), 
                                  size: glyphRect.size)).fill()

      }
      glyphRect.origin.x += advancement

    }
  }
}

/// Minimap layout fragments replaces all line fragments by a our own variant of minimap line fragments, which draw
/// coloured boxes instead of actual glyphs.
///
class MinimapLayoutFragment: NSTextLayoutFragment {

  private var _textLineFragments: [NSTextLineFragment] = []

  private var observation: NSKeyValueObservation?

  @objc override dynamic var textLineFragments: [NSTextLineFragment] {
    return _textLineFragments
  }

  override init(textElement: NSTextElement, range rangeInElement: NSTextRange?) {
    super.init(textElement: textElement, range: rangeInElement)
    observation = super.observe(\.textLineFragments, options: [.new]){ [weak self] _, _ in

      // NB: We cannot use `change.newValue` as this seems to pull the value from the subclass property (which we
      //     want to update here). Instead, we need to directly access `super`. This is, however as per Swift 5.9
      //     not possible in a closure weakly capturing `self` (which we need to do here to avoid a retain cycle).
      //     Hence, we defer to an auxilliary method.
      self?.updateTextLineFragments()
    }
  }
  
  /// Update the text line fragments from the corresponding property of `super`.
  ///
  private func updateTextLineFragments() {
    _textLineFragments = super.textLineFragments.map(MinimapLineFragment.init)
  }

  required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }
}

class MinimapTextLayoutManagerDelegate: NSObject, NSTextLayoutManagerDelegate {

  // We create instances of our own flavour of layout fragments
  func textLayoutManager(_ textLayoutManager: NSTextLayoutManager,
                         textLayoutFragmentFor location: NSTextLocation,
                         in textElement: NSTextElement)
  -> NSTextLayoutFragment
  {
    guard let paragraph = textElement as? NSTextParagraph
    else { return NSTextLayoutFragment(textElement: textElement, range: nil)  }

    return MinimapLayoutFragment(textElement: paragraph, range: nil)
  }
}


// MARK: -
// MARK: Geometry helpers

/// Compute the size of the code view in number of characters such that we can still accommodate the minimap.
///
/// - Parameters:
///   - width: Overall width available for main and minimap code view *without* gutter and padding.
///   - font: The fixed pitch font of the main text view.
///   - withMinimap: Determines whether to include the presence of a minimap into the calculation.
/// - Returns: The width of the code view in number of characters.
///
func codeWidthInCharacters(for width: CGFloat, with font: NSFont, withMinimap: Bool) -> CGFloat {
  let minimapCharWidth = withMinimap ? minimapFontSize(for: font.pointSize) / 2 : 0
  return floor(width / (font.maximumAdvancement.width + minimapCharWidth))
}

/// Compute the font size for the minimap from the font size of the main text view.
///
/// - Parameter fontSize: The font size of the main text view
/// - Returns: The font size for the minimap
///
/// The result is always divisible by two, to enable the use of full pixels for the font width while avoiding aspect
/// ratios that are too unbalanced.
///
func minimapFontSize(for fontSize: CGFloat) -> CGFloat {
  return max(1, ceil(fontSize / 20)) * 2
}
